<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Amortized Analysis | Nam Gyu Lee </title> <meta name="author" content="Nam Gyu Lee"> <meta name="description" content="Concepts and understanding of Amortized Analysis"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link defer href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://namdarine.github.io/blog/2023/Amortized-Analysis/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Nam Gyu¬†</span> Lee </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">Home </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/projects/">projects</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">Amortized Analysis</h1> <p class="post-meta"> March 23, 2023 </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a> ¬† ¬∑ ¬† <a href="/blog/tag/wil"> <i class="fa-solid fa-hashtag fa-sm"></i> WIL</a> ¬† ¬† ¬∑ ¬† <a href="/blog/category/algorithm"> <i class="fa-solid fa-tag fa-sm"></i> Algorithm</a> ¬† </p> </header> <article class="post-content"> <div id="markdown-content"> <blockquote> <p>Amortized analysis analyzes the costs associated with a data structure that averages the worst operations out over time.</p> </blockquote> <p>A data structure has one particularly costly operation, but it doesn‚Äôt get performed very often. That data structure shouldn‚Äôt be labeled costly just because that one operation, which is seldom performed, is costly. So, amortized analysis is used to <strong>average out the costly operations in the worst case.</strong> The worst-case scenario for a data structure is the absolute worst ordering of operations from a cost perspective. Once that ordering is found, then the operations can be averaged.</p> <p>=&gt; Refers to determining the time-averaged running time for a sequence operation, not an individual. It is different from average case analysis because we don‚Äôt assume that the data is arranged in an <u>average fashion</u>, not very bad, as we do for average case analysis for quick-sort. It applies to the method that consists of the sequence of operations, where a vast majority of operations are cheap but some of the operations are expensive.</p> <p><mark>The amortized analysis gives us the average performance of a series of operations in the worst case. It is useful when an operation or a set of operations occur successively, but only very a few of them have a bad complexity.</mark></p> <p>Three main types of amortized analysis - Aggregate analysis : Calculate the total cost of <em>n</em> operations first - Accounting method : save coins to a ‚Äúvirtual bank‚Äù when an operation is ‚Äúcheap‚Äù, and we use the saved coins to pay for an ‚Äúexpansive‚Äù operation. - Potential method</p> <h1 id="increment-in-a-binary-counter">Increment in a binary counter</h1> <p>Given a (<em>k</em>-bit) binary counter <em>A</em>, we can see the time complexity of an <strong>Increment(<em>A</em>)</strong> is the number of flips to increase the counter value by 1. For example, in this binary counter, the cost to increment from 7 to 8 is 4, since we need to flip 4 digits. In general, it is easy to see that <strong>Increment(<em>A</em>)</strong> has worst-case time complexity <em>k</em>, since we might need to flip all digits in one incrementing.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/Amortized_Analysis-480.webp 480w,/assets/img/Amortized_Analysis-800.webp 800w,/assets/img/Amortized_Analysis-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/Amortized_Analysis.png" class="img-fluid rounded z-depth-1" width="400" height="600" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h2 id="the-amortized-cost-of-incrementa">The amortized cost of <strong>Increment(<em>A</em>)</strong> </h2> <h3 id="aggregate-analysis">Aggregate analysis</h3> <p>On the right-hand side of the counter in the above image, we can see that after 16 calls, the total cost of <strong>Increment(<em>A</em>)</strong> is 31, we can guess that the amortized cost of <strong>Increment(<em>A</em>)</strong> is \(\frac{31}{16} \approx 2\), which is a constant and independent from <em>k</em></p> <p>A common example is a modified <u>stack</u>.</p> <h4 id="observation">Observation</h4> <p>The least significant bit flips in every increment, the second least significant bit flips in every two increments, and the third insignificant bit flips in every four increments‚Ä¶ If there are <em>m</em> <strong>Increment(<em>A</em>)</strong> operations, the total running time is : \(m + \frac {m}{2} + \frac {m}{4} + \cdots = 2m\). Thus, the amortized cost of <strong>Increment(<em>A</em>)</strong> is \(\frac {2m}{m} = 2\).</p> <h3 id="accounting-method">Accounting method</h3> <blockquote> <p>Accounting method is aptly named because it borrows ideas and terms from accounting.</p> </blockquote> <p>Each operation is assigned a charge, called the amortized cost. Some operations can be charged more or less than they actually cost. If an operation‚Äôs amortized cost exceeds its actual cost, we assign the difference, called a credit, to specific objects in the data structure. Credit can be used later to help pay for other operations whose amortized cost is less than their actual cost. Credit can never be negative in any sequence of operations. The amortized cost of an operation is split between an operation‚Äôs actual cost and credit that is either deposited or used up. Each operation can have a different amortized cost, unlike aggregate analysis. Choosing the amortized cost for each operation is important, <u>but the costs must always be the same for a given operation no matter what the sequence of operations, just like for any method of amortized analysis.</u></p> <p>Assume that each flip is worth 1 coin (1 operation), but we pay one extra coin (and save the coin on that digit) when flipping a digit from 0 to 1. We use that saved coin to flip that digit from 1 back to 0 later.</p> <h4 id="observation-1">Observation</h4> <p>In each <strong>Increment(<em>A</em>)</strong> operation, we flip exactly one digit from 0 to 1. Whenever we need to flip a digit from 0 at the \(q^{th}\) insignificant digit to 1, we need to flip all the q - 1 insignificant digits from 1 to 0.</p> <p>Thus, an <strong>Increment(<em>A</em>)</strong> operation that the \(q^{th}\) insignificant digit from 0 to 1 has amortized cost: \(2 + 0 \times (q - 1) = 2\).</p> <h3 id="potential-method">Potential method</h3> <p>The potential method is similar to the accounting method. However, instead of thinking about the analysis in terms of cost and credit, the potential method thinks of work already done as potential energy that can pay for later operations. This is similar to how rolling a rock up a hill creates potential energy that then can bring it back down the hill with no effort. Unlike the accounting method, however, potential energy is associated with the data structure as a whole, not with individual operations.</p> <p>A potential function \(\Phi\) is defined on a data structure or a system, it describes the ‚Äúpotential energy‚Äù stored (or ‚Äúmoney‚Äù saved) in a system or a data structure. For the same system, the potential function \(\Phi\) can be defined in many ways, but we require that <strong>\(\Phi\) needs to be non-negative</strong> after each operation. It‚Äôs like a debit card, sometimes you need to use your savings, but you are not allowed to have a negative amount of money in the account.</p> <p>For \(i = 1, 2, \cdots\) let \(c_i\) be the actual cost of the \(i^{th}\) operation in a series, let \(\hat{c_i}\) be the amortized cost of the \(i^{th}\) operation, let \(D_i\) be the system after the \(i^{th}\) operation and \(\Phi(D_i)\) be the potential in the system after the \(i^{th}\) operation,</p> \[\hat{c_i} = c_i + \Phi(D_i) - \Phi(D_{i-1}) = c_i + \Delta(\Phi(D_i))\] <p>=&gt; The amortized cost of the \(i^{th}\) operation equals to the actual cost of theat operation plus the change that operation makes in the potential.</p> <p>It is not always easy to find a useful potential function, but in general we want the potential to increase a little after a ‚Äúcheap‚Äù operation and the potential drops a lot after an ‚Äúexpansive‚Äù operation.</p> <p>For binary counter, can define \(\Phi\) as ‚Äúnumber of 1‚Äôs on the binary counter‚Äù, and use \(A_i\) to represent the binary counter after the \(i^{th}\) <strong>Increment(<em>A</em>)</strong> operation. <strong>Increment(<em>A</em>)</strong> operation which flips the \(q^{th}\) insignificant digit from 0 to 1 has amortized cost:</p> \[\hat{c_i} = c_i + \Phi(A_i) - \Phi(A_{i-1}) = c_i + \Delta(\Phi(A_i))\] \[= q + (1 - (q - 1))\] \[= 2\] <p>Using different potential functions on the same system will give you different amortized costs. If the function didn‚Äôt give you an amortized cost as you expected, it means this potential function is not useful for this system, and it doesn‚Äôt mean all other potential functions cannot give you the expected amortized cost.</p> <h4 id="prove">Prove</h4> <p><strong>A typical way to do this is to define \(\Phi(D_0) = 0\) and show that \(\Phi(D_i) \ge 0\).</strong> =&gt; The \(i^{th}\) operation will have a potential difference of \(\Phi(D_i) - \Phi(D_{i-1})\). If this value is positive, then the amortized cost $a_i$ is an overcharge for this operation, and the potential energy of the data structure will increase. If it is negative, it is an undercharge, and the potential energy of the data structure will decrease. At the binary counter. The potential function chosen will simply be the number of operations on the binary counter. Therefore, before the sequence of operations begins, \(\Phi(D_0) = 0\) because there are no operations in the binary counter. For all future operations, it‚Äôs clear that \(\Phi(D_i) \ge 0\) because there cannot be a negative number of operations in the binary counter. Calculating the potential difference for an <strong><em>Increment(A)</em></strong> operation, we find that \(\Phi(D_i) - \Phi(D_{i-1}) = (size + 1) - size = 1\) So, the amortized cost of the <strong><em>Increment(A)</em></strong> is \(a_i = c_i + \Phi(D_i) - \Phi(D_{i-1}) = 1 + 1 = 2\) All of these operations have an amortized cost of \(O(1)\), so any sequence of operations of length <em>n</em> will take <em>O(n)</em> time. Since it was proven that \(\Phi(D_i) \ge \Phi(D_0)\) for all \(i\), this is a true upper bound. The worst case of \(n\) operations are therefore \(O(n)\).</p> <h2 id="example">Example</h2> <p>We‚Äôve seen that A[1] is flipped \(\frac{n}{2}\) times and that A[2] is flipped \(\frac{n}{4}\) times. For an A of length <em>k</em>, how many bits are flipped for <em>n</em> increment operations? What does this mean for aggregate analysis? <br> -&gt; For each A[i] where \(i\) is \({0, 1, \cdots, k-1}\), bit \(i\) is flipped \(\frac{n}{2^i}\). The summation is then \(\Sigma_{i = 0}^{k-1} {\frac{n}{2^i}} &lt; n\Sigma_{i=0}^{\infty} {\frac{1}{2^i}} = 2n\). So, there are 2n flips and this takes \(O(n)\) times. Using aggregate analysis \(\frac{T(n)}{n} = \frac{O(n)}{n} = O(1)\).</p> <p><strong>Suppose we wish not only to increment value in a ùëò-digit binary counter ùê¥, but also to reset the value in ùê¥ to 0. Counting the cost of each flip as 1, can you implement Increment(ùê¥) and Reset(ùê¥) such that any sequence of ùëö Increment(ùê¥) and Reset(ùê¥) operations cost ùëÇ(ùëö)? In other words, each operation in the sequence has amortized cost ùëÇ(1), which is a constant and independent from ùëò. If you can, show how; if you think it is impossible, show why.</strong></p> <p>=&gt; Yes, it is possible. It uses a binary representation of <em>A</em> as an array of <em>k</em> bits. Increment(A) operation is performed as starting from the least significant bit, flip the first 0 bit encountered to 1 and if 1 bit is flipped to 0, repeat the previous step for the next bit until 0 bit is flipped to 1 or the most significant bit is reached. Each bit flip in an Increment(A) operation costs 1. However, the number of bits that need to be flipped is at most <em>k,</em> which is constant. Thus, the amortized cost of an Increment(A) operation is O(1). The Reset(A) operation is performed by setting all bits to 0. It costs <em>k</em> flips, which is also a constant. Therefore, the amortized cost of a Reset(A) operation is O(1). The Increment(A) operation flips a maximum of <em>k</em> bits and the Reset(A) operation flips <em>k</em> bits. Therefore, any sequence of <em>m</em> operations a <em>A</em> has an O(m) cost in total, which means that the amortized cost of each operation in the sequence is O(1).</p> <h1 id="reference">Reference</h1> <ul> <li>CS 430, Introduction to Algorithm, prof. Wang, Xiaolang, Spring 2023, Illinois Institute of Technology</li> <li>Amortized analysis. Brilliant Math &amp; Science Wiki. (n.d.). <a href="https://brilliant.org/wiki/amortized-analysis/" rel="external nofollow noopener" target="_blank">brilliant.org/wiki/amortized-analysis</a> </li> </ul> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/Dynamic-Table/">Dynamic Table</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/ML-Final_Prep/">Machine Learning Final Preparation</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/Growth-of-Function/">Growth of Function - Big O</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2022/Binary-Search-Tree/">Binary Search Tree (BST)</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/Discrete-Math/">Discrete Math &amp; Proposition and Logical operation 1</a> </li> </div> </div> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> ¬© Copyright 2024 Nam Gyu Lee. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?4a129fbf39254905f505c7246e641eaf"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>